/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2016 Ales Hvezda
 * Copyright (C) 1998-2016 gEDA Contributors (see ChangeLog for details)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA
 */

#include <gschem.h>
#include <version.h>

#include <X11/Xlib.h>
/* Xlib defines Complex to be a numeric of value 0 and this does
 * interfere with Libgeda's definition of Complex, so we will undefine
 * X11's seemly trivial definition: */
#ifdef Complex
#undef Complex
#endif

#include <geda_dialogs.h>

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#include <geda_debug.h>

/* These are generated by parse_commandline() */
extern SCM s_pre_load_expr;
extern SCM s_post_load_expr;

typedef struct {
  void (*func)(void*);
  void* arg;
} geda_atexit_struct;

static GList     *exit_functions  = NULL; /* to be done after loop ends */
static GMainLoop *main_loop       = NULL;

void shut_down_gui (void)
{
  if (main_loop && g_main_loop_is_running (main_loop)) {
    g_main_loop_quit(main_loop);
  }
}

/*! \brief Register a function to be called on program exit
 *
 *  \par Function Description
 *  This function registers a function to be called on
 *  program exit. Multiple functions will be executed in
 *  the order they are registered.
 *
 *  \param [in] func Pointer to the function to be registered
 *  \param [in] data Arbitrary argument passed to \a func when
 *                   the function is called.
 */
void gschem_atexit(geda_atexit_func func, void* data)
{
  geda_atexit_struct *p;

  p = g_new(geda_atexit_struct, 1);
  p->func = func;
  p->arg = data;
  exit_functions = g_list_append(exit_functions, p);
}

/*! \brief Cleanup gSchem on exit.
 *  \par Function Description
 *  This function cleans up all memory objects allocated during the
 *  gschem runtime.
 */
void gschem_quit(void)
{
  GList *list;

  /* Call registered functions in atexit list */
  list = exit_functions;

  while(list != NULL) {

    geda_atexit_struct *ptr;

    ptr = (geda_atexit_struct*)list->data;
    ptr->func(ptr->arg);
    GEDA_FREE(ptr);
    list = g_list_next(list);
  }
  g_list_free(exit_functions);

  libgeda_release();
  libgedacolor_release();

  x_menu_free_all();

#ifdef HAVE_LIBSTROKE
  x_stroke_free ();
#endif /* HAVE_LIBSTROKE */
  o_undo_finalize();

  i_vars_freenames();
  i_command_shutdown();

  g_list_free (global_window_list);
}

static void
load_documents(GschemToplevel *w_current, int argv_index, int argc, char *argv[])
{
  int   page_loaded   = FALSE;
  char *cwd           = NULL;
  char  tmpfilename[MAX_PATH];

  cwd = g_get_current_dir();

  if (comline_tblock) { /* If title-block was specified on command line */

    Page *page = x_window_open_page(w_current, NULL);

    if (o_edit_add_titleblock(w_current, page, comline_tblock)) {

      i_zoom_world_extents (w_current, geda_struct_page_get_objects (page), I_PAN_DONT_REDRAW);

      geda_page_set_changed (page, FALSE);

      ++page_loaded;
    }
    GEDA_FREE(comline_tblock);
  }
  else {

    int   i;

    /* Load any file listed on command-line */
    for (i = argv_index; i < argc; i++) {

      char *filename;

      /* Check for non-expanded wild-card, if not match then no expansion */
      if (strstr(argv[i], "*") != NULL) {
        geda_log(_("Warning: <%s> did not expand\n"), argv[i]);
        geda_log_v (_("Command-line error: disabling auto load last\n"));
        override_autoload = TRUE;
        continue;
      }

      if (geda_file_get_is_path_absolute(argv[i])) {

        /* Path is already absolute so no need to do any concat of cwd */
        filename = geda_utility_string_strdup (argv[i]);
      }
      else {
        filename = g_build_filename (cwd, argv[i], NULL);
      }

      /* if filename is not valid, check if user left off extension */
      if (access(filename, F_OK ) == -1 ) {

        /* See if user left off our file suffixes */
        const char *ext = geda_file_get_filename_ext(filename);

        if (!ext) {

          memset(tmpfilename, 0, sizeof(tmpfilename));

          /* Check if file name is valid if ".sch" is added */
          strcpy(tmpfilename, filename);

          if (access( strcat(tmpfilename, SCHEMATIC_FILE_DOT_SUFFIX), F_OK ) != -1 ) {

            filename = tmpfilename;

            if (verbose_mode) {
              const char *fname = geda_get_basename (filename);
              geda_log (_("Assumming schematic file suffix for [%s]\n"), fname);
            }
          }
          else {

            /* Check if file name is valid if ".sym" is added */
            strcpy(tmpfilename, filename);

            if ( access( strcat(tmpfilename, SYMBOL_FILE_DOT_SUFFIX), F_OK ) != -1 ) {

              filename = tmpfilename;

              if (verbose_mode) {
                const char *fname = geda_get_basename (filename);
                geda_log (_("Assumming symbol file suffix for [%s]\n"), fname);
              }
            }
          }
        }
      }

      /*
       * \notes SDB: at this point the filename might be unnormalized, like
       * /path/to/foo/../bar/baz.sch. Bad filenames will be normalized in
       * geda_file_open, called by x_window_open_page. This works for Linux
       * and MINGW32.
       */

      if (x_window_open_page(w_current, filename)) {
        ++page_loaded;
      }

      /* Free the pointer if we did not redirected */
      if ( filename != tmpfilename ) {
        GEDA_FREE (filename);
      }
    }
    GEDA_FREE(cwd);
  }

  if (!page_loaded) { /* If no files have been loaded, then ... */

    /*! \brief Sessions */
    if (start_session) { /* If session specified on command line */
      if (!i_sessions_open_session(w_current, start_session)) {
        geda_log_q(_("An error was encountered loading requested session %s\n"), start_session);

        /* Open a blank document */
        x_window_open_page( w_current, NULL);
      }
      GEDA_FREE(start_session);
    }
    else if (i_sessions_present_at_startup()) {
      /* Open a blank document */
      x_window_open_page( w_current, NULL);
      x_sessions_open_dialog(w_current);
    }
    else {

      int load_last;

      /*! \brief Auto-Load */
      /* Retrieve the setting for auto-load-last */
      auto_load_last = default_auto_load_last;

      load_last = auto_load_last && !override_autoload;

      /* Check and do Auto Load if file recordered */
      if ((load_last) && (x_menu_recent_files_last() != NULL)) {
         /* maybe Log what we are doing */
        geda_log_q("Auto Load: . . .%s\n", x_menu_recent_files_last());
        x_window_open_page(w_current, x_menu_recent_files_last());
      }
      else {

        /* Still no page has been loaded, start with blank page */
        x_window_open_page( w_current, NULL );
      }
    }
  }

  /* Update the window to show the current page */
  x_window_set_current_page( w_current, Current_Page);
}

static void gschem( int argc, char *argv[])
{
  int   argv_index;
  char *input_str     = NULL;

  GschemToplevel *w_current = NULL;
  GedaToplevel   *toplevel;

  SCM scm_tmp;

  argv_index = gschem_parse_commandline(argc, argv);

  libgeda_init(argc, argv);
  libgedacolor_init(&argc, argv);

#if defined(__MINGW32__) && defined(DEBUG)
    printf("This is the MINGW32 port.\n");
#endif

  /* init global buffers */
  o_buffer_init();

  /* register guile (scheme) functions */
  g_register_funcs();
  g_init_window ();
  g_init_select ();
  g_hook_init ();
  g_init_attrib ();
  g_keys_init ();
  g_init_builtins ();
  g_init_util ();

  if (geda_sys_data_path () == NULL) {
    const char *message =
      _("You must set the GEDADATA environment variable!\n\n"
        "gschem cannot locate some data files. Please ensure the GEDADATA\n"
        "environment variable points to the correct location.\n");

    titled_error_dialog("gschem", message);
    g_error ("%s", message);
  }


  /* Allocate w_current */
  w_current           = gschem_toplevel_new ();
  w_current->toplevel = geda_toplevel_new ();
  toplevel            = w_current->toplevel;

  geda_toplevel_set_bkloader_query_func(toplevel,
                                        x_fileselect_load_backup,
                                        w_current);

  geda_toplevel_struct_set_rbounds_func (toplevel,
                                         o_text_get_rendered_bounds,
                                         w_current);

  scm_dynwind_begin (0);
  g_dynwind_window (w_current);

  /* Check for and run pre-load Scheme expressions */
  if (scm_ilength(s_pre_load_expr) - 1) {
    g_evaluate_scm_protected (s_pre_load_expr, scm_current_module ());
  }

  /* By this point, libgeda should have setup the Guile load path.
   * Note that the log system is not initialized yet so any messages
   * will go to the console or null */
  scm_tmp = scm_sys_search_load_path (scm_from_utf8_string ("gschem.scm"));

  if (scm_is_false (scm_tmp)) {
    geda_log (_("Unable to locate scheme initialization file \"gschem.scm\"\n"));
  }
  else {

    input_str = scm_to_utf8_string (scm_tmp);

    if (g_evaluate_scheme_file(input_str, NULL)) {
      geda_log_v (_("Read scheme initialization file [%s]\n"), input_str);
    }
    else {
      geda_log (_("Failed to read initialization scheme file [%s]\n"), input_str);
    }
  }
  free (input_str); /* M'allocated by scm_to_utf8_string() */
  scm_remember_upto_here_1 (scm_tmp);

  /*! \internal Initialize default configuration Settings */
  i_vars_init(w_current);         /* Set defaults */

  if (w_current->save_ui_settings) {
    gschem_atexit (i_vars_atexit_save_user_config, NULL);
  }

  /*! \internal Begin Setup Log & Console System */
  x_console_init_commands(w_current, run_mode);

  if (logging == TRUE) {

    geda_utility_log_init ("gschem");

    /* see if open up console/log window on startup  */
    if (!iconify_main_window && console_window == MAP_ON_STARTUP) {
      x_console_open (w_current);
    }

    /* now we can spam the log */
    geda_log (_("gEDA/gschem version %s%s.%s\n"), PREPEND_VERSION_STRING,
                                                  PACKAGE_DOTTED_VERSION,
                                                  PACKAGE_DATE_VERSION);
  }
  else {
    geda_log_v(_("Logging system is disabled\n"));
  }

  /*! \internal End Setup Log & Console Systems > */

  /* Initialize the Undo system */
  o_undo_init(w_current);

  /* Load recent files list before calling x_window_setup.*/
  x_menu_recent_files_load();
  gschem_atexit(x_menu_recent_files_save, NULL);

  /*! \internal Bring up the GUI */
  x_window_setup (w_current);

  x_image_init();

#ifdef HAVE_LIBSTROKE
  x_stroke_init ();
#endif /* HAVE_LIBSTROKE */

  /*! \internal Initialize Sessions system */
  i_sessions_init(w_current);

  load_documents(w_current, argv_index, argc, argv);

  gschem_page_history_seed_back(w_current->page_history, geda_toplevel_get_pages (toplevel));

#if DEBUG
  scm_c_eval_string ("(display \"hello guile\n\")");
#endif

  /* Run post-load expressions */
  if (scm_ilength(s_post_load_expr) - 1) {

    SCM s_result;

    s_result = g_evaluate_scm_protected (s_post_load_expr, scm_current_module ());

    if (scm_is_false (s_result)) {
      fprintf(stderr, _("ERROR: Failed to load or evaluate startup script.\n"));
    }
  }

  scm_dynwind_end ();

  /* if there were any symbols which had major changes, show error dialog */
  x_dialog_symbol_changed(w_current);
}

/*! \brief Main Scheme(GUILE) program function.
 *  \par Function Description
 *  This function is the main program called from scm_boot_guile.
 *  It handles initializing all libraries and gSchem variables
 *  and passes control to the gtk main loop.
 */
static void main_prog(void *closure, int argc, char *argv[])
{

#ifdef HAVE_X11
  XInitThreads();
#endif

#if !GLIB_CHECK_VERSION(2, 44, 0)
  geda_utility_program_mem_set_vtable();
#endif


#if ((GLIB_MAJOR_VERSION >= 2 ) && (GLIB_MINOR_VERSION <= 33 ))
  g_slice_set_config(G_SLICE_CONFIG_ALWAYS_MALLOC, 1);
#endif

#ifdef HAVE_GTHREAD

  /* Initialise threading before any more GLib functions are called. */

#if ((GLIB_MAJOR_VERSION == 2 ) && (GLIB_MINOR_VERSION < 32 ))

  g_thread_init (NULL);

#endif

  if (gschem_threads_init()) {
    run_mode = 2;
  }

#else

  run_mode = 1;

#endif

#if ENABLE_NLS

  /* This should be equivalent to setlocale (LC_ALL, "") */
  gdk_set_locale();

  /* This must be the same for all locales,  use decimal point instead
   * of comma, use "C" or "POSIX" */
  setlocale(LC_NUMERIC, "C");

  /* Prevent gtk_init() and gtk_init_check() from automatically
   * calling setlocale (LC_ALL, "") which would undo our LC_NUMERIC. */
  gtk_disable_setlocale();

# if DEBUG

  fprintf(stderr, "Current locale settings: %s\n", setlocale(LC_ALL, NULL));

# endif

#endif

  if (gtk_init_check(&argc, &argv)) {

    gschem(argc, argv);

    /* create a main loop */
    main_loop  = g_main_loop_new (NULL, TRUE);

    if (g_main_loop_is_running (main_loop)) {

      gschem_threads_leave();  /* I know, seems backwards */
      /* enter main loop */
      g_main_loop_run(main_loop);
      gschem_threads_enter();
      gdk_flush ();
    }

    g_main_loop_unref(main_loop);

    gschem_quit();
    geda_log_v (_("Exiting normal\n"));
  }
  else {
    fprintf (stderr, "FAILED: gtk_init_check\n");
    exit (1);
  }
}

/*! \brief Main executable entrance point.
 *  \par Function Description
 *  This is the main function for gschem. The function sets up the Scheme
 *  (GUILE) environment and passes control to via scm_boot_guile to the
 *  #main_prog function.
 */
int main (int argc, char *argv[])
{

#if ENABLE_NLS
  setlocale(LC_ALL, "");
  setlocale(LC_NUMERIC, "C");
  bindtextdomain("geda-gschem", LOCALEDIR);
  textdomain("geda-gschem");
  bind_textdomain_codeset("geda-gschem", "UTF-8");
#endif

  scm_boot_guile (argc, argv, main_prog, 0);
  return 0;
}
