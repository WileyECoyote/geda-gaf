/* gEDA - GPL Electronic Design Automation
 * gschem - gEDA Schematic Capture
 * Copyright (C) 1998-2016 Ales Hvezda
 * Copyright (C) 1998-2016 gEDA Contributors (see ChangeLog for details)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301 USA
 */

#include "../../include/gschem.h"

#include <version.h>

#ifdef HAVE_X11
#  include <X11/Xlib.h>
   /* Xlib defines Complex to be a numeric of value 0 and this does
    * interfere with Libgeda's definition of Complex, so we will undefine
    * X11's seemly trivial definition: */
#  ifdef Complex
#    undef Complex
#  endif
#endif /* HAVE_X11 */

#include <geda_dialogs.h>

#ifdef HAVE_LOCALE_H
#include <locale.h>
#endif

#include <geda_debug.h>

/* These are generated by parse_commandline() */
extern SCM s_pre_load_expr;
extern SCM s_post_load_expr;

typedef struct {
  void (*func)(void*);
  void* arg;
} geda_atexit_struct;

static GList     *exit_functions  = NULL; /* to be done after loop ends */
static GMainLoop *main_loop       = NULL;

void shut_down_gui (void)
{
  if (main_loop && g_main_loop_is_running (main_loop)) {
    g_main_loop_quit(main_loop);
  }
}

/*! \brief Register a function to be called on program exit
 *
 *  \par Function Description
 *  This function registers a function to be called on
 *  program exit. Multiple functions will be executed in
 *  the order they are registered.
 *
 *  \param [in] func Pointer to the function to be registered
 *  \param [in] data Arbitrary argument passed to \a func when
 *                   the function is called.
 */
void gschem_atexit(geda_atexit_func func, void* data)
{
  geda_atexit_struct *p;

  p = geda_malloc(sizeof(geda_atexit_struct));
  p->func = func;
  p->arg = data;
  exit_functions = g_list_append(exit_functions, p);
}

/*! \brief Cleanup gSchem on exit.
 *  \par Function Description
 *  This function cleans up all memory objects allocated during the
 *  gschem runtime.
 */
void gschem_quit(void)
{
  GList *list;

  /* Call registered functions in atexit list */
  list = exit_functions;

  while(list != NULL) {

    geda_atexit_struct *ptr;

    ptr = (geda_atexit_struct*)list->data;
    ptr->func(ptr->arg);
    geda_free(ptr);
    list = g_list_next(list);
  }
  g_list_free(exit_functions);

  libgeda_release();
  libgedacolor_release();

  x_menu_free_all();

#if DEBUG_GEDA_LABEL
  /* This can be helpful in identifying unreleased resources */
  geda_label_report_instances();
#endif

#ifdef HAVE_LIBSTROKE
  x_stroke_free ();
#endif /* HAVE_LIBSTROKE */
  o_undo_finalize();

  i_vars_freenames();
  i_command_shutdown();

  g_list_free (global_window_list);
}

static void
load_documents(GschemToplevel *w_current, int argv_index, int argc, char *argv[])
{
  int   page_loaded = FALSE;
  char *cwd         = NULL;


  char *get_file_name(int index) {

    char *filename;

    if (geda_file_get_is_path_absolute(argv[index])) {

      /* Path is already absolute so no need to do any concat of cwd */
      filename = geda_utility_string_strdup (argv[index]);
    }
    else {
      filename = g_build_filename (cwd, argv[index], NULL);
    }

    return filename;
  }

  cwd = g_get_current_dir();

  /* Check if a title-block was specified on the command line */
  if (comline_tblock) {

    char *fname;
    Page *page;

    fname = get_file_name (argv_index);

    /* Check is user passed the filename after the titleblock,
     * the directory would be the cwd from get_file_name which
     * occurs when the user does not pass the file name */
    if (fname && !g_file_test(fname, G_FILE_TEST_IS_DIR)) {
      page = x_window_open_page (w_current, fname);
    }
    else {
      page = x_window_open_page (w_current, NULL);
    }

    if (o_edit_add_titleblock(w_current, page, comline_tblock)) {

      geda_page_set_changed (page, FALSE);

      ++page_loaded;
    }

    GEDA_FREE (fname);
    GEDA_FREE (comline_tblock);
  }
  else {

    int   i;

    /* Load any file listed on command-line */
    for (i = argv_index; i < argc; i++) {

      char *filename;

      /* Check for non-expanded wild-card, if no match then no expansion */
      if (strstr(argv[i], "*") != NULL) {
        geda_log(_("Warning: <%s> did not expand\n"), argv[i]);
        geda_log_v (_("Command-line error: disabling auto load last\n"));
        override_autoload = TRUE;
        continue;
      }

      filename = get_file_name(i);

      /* if filename is not valid, check if user left off extension */
      if (access(filename, F_OK ) == -1) {

        char *tmpfilename;

        /* See if user left off our file suffixes */
        const char *ext = geda_file_get_filename_ext(filename);

        if (!ext) {

          tmpfilename = geda_calloc(strlen(filename) + 5);

          /* Check if file name is valid if ".sch" is added */
          strcpy(tmpfilename, filename);

          if (access(strcat(tmpfilename, SCHEMATIC_FILE_DOT_SUFFIX), F_OK ) != -1 ) {

            GEDA_FREE (filename);

            filename = tmpfilename;

            if (verbose_mode) {
              const char *fname = geda_get_basename (filename);
              geda_log ("%s \"%s\"\n", _("Assuming schematic file suffix for"), fname);
            }
          }
          else {

            /* Check if file name is valid if ".sym" is added */
            strcpy(tmpfilename, filename);

            if (access(strcat(tmpfilename, SYMBOL_FILE_DOT_SUFFIX), F_OK ) != -1 ) {

              GEDA_FREE (filename);

              filename = tmpfilename;

              if (verbose_mode) {
                const char *fname = geda_get_basename (filename);
                geda_log ("%s \"%s\"\n", _("Assuming symbol file suffix for"), fname);
              }
            }
          }
        }
      }

      /*
       * \notes SDB: at this point the filename might be unnormalized, like
       * /path/to/foo/../bar/baz.sch. Bad filenames will be normalized in
       * geda_file_open, called by x_window_open_page. This works for Linux
       * and MINGW32.
       */

      if (x_window_open_page(w_current, filename)) {
        ++page_loaded;
      }

      GEDA_FREE (filename);
    }
  }

  if (!page_loaded) { /* If no files have been loaded, then ... */

    /*! \internal Sessions */
    if (start_session) { /* If session specified on command line */

      if (!i_sessions_open_session(w_current, start_session)) {

        /* There was an error loading the requested session */
        geda_log_q("%s: %s\n", _("An error was encountered loading requested session"), start_session);

        /* Open a blank document */
        x_window_open_page( w_current, NULL);
      }
      GEDA_FREE(start_session);
    }
    else if (i_sessions_present_at_startup()) {
      /* Open a blank document */
      x_window_open_page( w_current, NULL);
      x_sessions_open_dialog(w_current);
    }
    else {

      int load_last;

      /*! \internal Auto-Load */
      /* Retrieve the setting for auto-load-last */
      auto_load_last = default_auto_load_last;

      load_last = auto_load_last && !override_autoload;

      /* Check and do Auto Load if file recordered */
      if (load_last) {

        const char *last_file = x_menu_recent_files_last();

        if (last_file && !access(last_file, F_OK )) {

          /* maybe Log what we are doing */
          geda_log_q("%s: ...%s\n", _("Auto Load"), last_file);
          x_window_open_page(w_current, last_file);
        }
        else {

          /* No page has been loaded, start with blank page */
          x_window_open_page( w_current, NULL );
        }
      }
      else {

        /* Still no page has been loaded, start with blank page */
        x_window_open_page( w_current, NULL );
      }
    }
  }

  /* Update the window to show the current page */
  x_window_set_current_page( w_current, Current_Page);

  /* No matter what happened above, restore the directory */
  if (!chdir(cwd));
  GEDA_FREE(cwd);
}

static void gschem( int argc, char *argv[])
{
  int argv_index;

  GschemToplevel *w_current = NULL;

  SCM scm_tmp;

  argv_index = gschem_parse_commandline(argc, argv);

  libgeda_init(argc, argv);
  libgedacolor_init(&argc, argv);
  libgedauio_setup_locale();

#if defined(__MINGW32__) && defined(DEBUG)
    printf("This is the MINGW32 port.\n");
#endif

  /* init global buffers */
  o_buffer_init();

  /* register guile (scheme) functions */
  g_register_funcs();
  g_init_window ();
  g_init_select ();
  g_hook_init ();
  g_init_attrib ();
  g_keys_init ();
  g_init_builtins ();
  g_init_util ();

  if (geda_sys_data_path () == NULL) {
    const char *message =
      _("The GEDADATA environment variable must be set!\n\n"
        "gschem cannot locate some data files. Please ensure the GEDADATA\n"
        "environment variable points to the correct location.\n");

    titled_error_dialog("gschem", message);
    g_error ("%s", message);
  }

  /* Allocate w_current */
  w_current           = gschem_toplevel_new ();
  w_current->toplevel = geda_toplevel_new ();

  geda_toplevel_set_bkloader_query_func(w_current->toplevel,
                                        x_fileselect_load_backup,
                                        w_current);

  geda_toplevel_struct_set_rbounds_func (w_current->toplevel,
                                         o_text_get_rendered_bounds,
                                         w_current);

  scm_dynwind_begin (0);
  g_dynwind_window (w_current);

  /* Check for and run pre-load Scheme expressions */
  if (scm_ilength(s_pre_load_expr) - 1) {
    g_evaluate_scm_protected (s_pre_load_expr, scm_current_module ());
  }

  /* By this point, libgeda should have setup the Guile load path.
   * Note that the log system is not initialized yet so any messages
   * will go to the console or null */
  scm_tmp = scm_sys_search_load_path (scm_from_utf8_string ("gschem.scm"));

  if (scm_is_false (scm_tmp)) {
    geda_log ("\n%s \"gschem.scm\".\n", _("Unable to locate scheme initialization file"));
  }
  else {

    char *input_str = scm_to_utf8_string (scm_tmp);

    if (g_evaluate_scheme_file(input_str, NULL)) {
      geda_log_v ("\n%s \"%s\".\n", _("Read scheme initialization file"), input_str);
    }
    else {
      geda_log ("\n%s \"%s\".\n", _("Failed to read scheme initialization file"), input_str);
    }

    free (input_str); /* M'allocated by scm_to_utf8_string() */
  }

  scm_remember_upto_here_1 (scm_tmp);

  /*! \internal Initialize default configuration Settings */
  i_vars_init(w_current);         /* Set defaults, calls x_rc_parse_gschem */

  /*! \internal Begin Setup Log & Console System */
  x_console_init_commands(w_current, run_mode);

  if (logging == TRUE) {

    geda_utility_log_init ("gschem");

    /* see if open up console/log window on startup  */
    if (!iconify_main_window && console_window == MAP_ON_STARTUP) {
      x_console_open (w_current);
    }

    /* now we can spam the log */
    geda_log ("gEDA/gschem %s %s%s.%s\n", _("version"), PREPEND_VERSION_STRING,
                                                        PACKAGE_DOTTED_VERSION,
                                                        PACKAGE_DATE_VERSION);
  }
  else {
    geda_log_v(_("Logging system is disabled\n"));
  }

  /*! \internal End Setup Log & Console Systems > */

  /* Initialize the Undo system */
  o_undo_init(w_current);

  /*! \internal Bring up the GUI */
  x_window_setup (w_current);

  x_image_init();

  /*! \internal Initialize Sessions system */
  i_sessions_init(w_current);

  load_documents(w_current, argv_index, argc, argv);

  gschem_page_history_seed_back(w_current->page_history,
                                geda_toplevel_get_pages (w_current->toplevel));

#if DEBUG
  scm_c_eval_string ("(display \"hello guile\n\")");
#endif

  /* Run post-load expressions */
  if (scm_ilength(s_post_load_expr) - 1) {

    SCM s_result;

    s_result = g_evaluate_scm_protected (s_post_load_expr, scm_current_module ());

    if (scm_is_false (s_result)) {
      fprintf(stderr, _("ERROR: Failed to load or evaluate startup script.\n"));
    }
  }

  scm_dynwind_end ();

  /* Window geometry should be stabilized now so zoom extents */
  i_window_zoom_all_pages(w_current);

  /* if there were any symbols which had major changes, show error dialog */
  x_dialog_symbol_changed(w_current);

  /* Get scroll events on MinGW */
  gdk_window_focus(w_current->window, GDK_CURRENT_TIME);
}

/*! \brief Main Scheme(GUILE) program function.
 *  \par Function Description
 *  This function is the main program called from scm_boot_guile.
 *  It handles initializing all libraries and gschem variables
 *  and passes control to the gtk main loop.
 */
static void main_prog(void *closure, int argc, char *argv[])
{

#ifdef HAVE_X11
  XInitThreads();
#endif

#if !GLIB_CHECK_VERSION(2, 44, 0)
  geda_utility_program_mem_set_vtable();
#endif

#if ((GLIB_MAJOR_VERSION >= 2 ) && (GLIB_MINOR_VERSION <= 33 ))
  g_slice_set_config(G_SLICE_CONFIG_ALWAYS_MALLOC, 1);
#endif

#ifdef HAVE_GTHREAD

  /* Initialize threading before any more GLib functions are called. */
  if (gschem_threads_init()) {
    run_mode = 2;
  }
  else {
    run_mode = 1;
  }

#else

  run_mode = 1;

#endif

#if ENABLE_NLS

  /* Initialize locale based on environment */
  setlocale (LC_ALL, "");

  /* This must be the same for all locales, use decimal point instead
   * of comma, use "C" or "POSIX" */
  setlocale(LC_NUMERIC, "C");

  /* Prevent gtk_init() and gtk_init_check() from automatically
   * calling setlocale (LC_ALL, "") which would undo our LC_NUMERIC. */
  gtk_disable_setlocale();

# if DEBUG

  fprintf(stderr, "Configured locale directory: %s\n", LOCALEDIR);
  fprintf(stderr, "Current locale settings: %s\n", setlocale(LC_ALL, NULL));

# endif

#endif

  if (gtk_init_check(&argc, &argv)) {

    gschem(argc, argv);

    /* create a main loop */
    main_loop  = g_main_loop_new (NULL, TRUE);

    if (g_main_loop_is_running (main_loop)) {

      gschem_threads_leave();  /* I know, seems backwards */
      /* enter main loop */
      g_main_loop_run(main_loop);
      gschem_threads_enter();
      gdk_flush ();
    }

    g_main_loop_unref(main_loop);

    gschem_quit();

    geda_log_v (_("Exiting normal\n"));
  }
  else {
    fprintf (stderr, "%s gtk_init_check\n", _("FAILED:"));
    exit (1);
  }
}

/*! \brief Main executable entrance point.
 *  \par Function Description
 *  This is the main function for gschem. The function sets up the Scheme
 *  (GUILE) environment and passes control to via scm_boot_guile to the
 *  #main_prog function.
 */
int main (int argc, char *argv[])
{

#if ENABLE_NLS
  setlocale(LC_ALL, "");
  setlocale(LC_NUMERIC, "C");
  bindtextdomain("geda-gschem", LOCALEDIR);
  textdomain("geda-gschem");
  bind_textdomain_codeset("geda-gschem", "UTF-8");
#endif

  scm_boot_guile (argc, argv, main_prog, 0);
  return 0;
}
